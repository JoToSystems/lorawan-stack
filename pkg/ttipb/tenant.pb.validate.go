// Code generated by protoc-gen-fieldmask. DO NOT EDIT.

package ttipb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"github.com/gogo/protobuf/types"

	ttnpb "go.thethings.network/lorawan-stack/v3/pkg/ttnpb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = types.DynamicAny{}

	_ = ttnpb.State(0)
)

// define the regex for a UUID once up-front
var _tenant_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// ValidateFields checks the field values on Tenant with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *Tenant) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = TenantFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "ids":

			if v, ok := interface{}(&m.TenantIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return TenantValidationError{
						field:  "ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "created_at":

			if v, ok := interface{}(&m.CreatedAt).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return TenantValidationError{
						field:  "created_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "updated_at":

			if v, ok := interface{}(&m.UpdatedAt).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return TenantValidationError{
						field:  "updated_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "name":

			if utf8.RuneCountInString(m.GetName()) > 50 {
				return TenantValidationError{
					field:  "name",
					reason: "value length must be at most 50 runes",
				}
			}

		case "description":

			if utf8.RuneCountInString(m.GetDescription()) > 2000 {
				return TenantValidationError{
					field:  "description",
					reason: "value length must be at most 2000 runes",
				}
			}

		case "attributes":

			for key, val := range m.GetAttributes() {
				_ = val

				if utf8.RuneCountInString(key) > 36 {
					return TenantValidationError{
						field:  fmt.Sprintf("attributes[%v]", key),
						reason: "value length must be at most 36 runes",
					}
				}

				if !_Tenant_Attributes_Pattern.MatchString(key) {
					return TenantValidationError{
						field:  fmt.Sprintf("attributes[%v]", key),
						reason: "value does not match regex pattern \"^[a-z0-9](?:[-]?[a-z0-9]){2,}$\"",
					}
				}

				// no validation rules for Attributes[key]
			}

		case "contact_info":

			for idx, item := range m.GetContactInfo() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return TenantValidationError{
							field:  fmt.Sprintf("contact_info[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		case "max_applications":

			if v, ok := interface{}(m.GetMaxApplications()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return TenantValidationError{
						field:  "max_applications",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "max_clients":

			if v, ok := interface{}(m.GetMaxClients()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return TenantValidationError{
						field:  "max_clients",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "max_end_devices":

			if v, ok := interface{}(m.GetMaxEndDevices()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return TenantValidationError{
						field:  "max_end_devices",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "max_gateways":

			if v, ok := interface{}(m.GetMaxGateways()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return TenantValidationError{
						field:  "max_gateways",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "max_organizations":

			if v, ok := interface{}(m.GetMaxOrganizations()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return TenantValidationError{
						field:  "max_organizations",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "max_users":

			if v, ok := interface{}(m.GetMaxUsers()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return TenantValidationError{
						field:  "max_users",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "state":

			if _, ok := ttnpb.State_name[int32(m.GetState())]; !ok {
				return TenantValidationError{
					field:  "state",
					reason: "value must be one of the defined enum values",
				}
			}

		case "capabilities":

			if v, ok := interface{}(&m.Capabilities).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return TenantValidationError{
						field:  "capabilities",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "configuration":

			if v, ok := interface{}(m.GetConfiguration()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return TenantValidationError{
						field:  "configuration",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "billing":

			if v, ok := interface{}(m.GetBilling()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return TenantValidationError{
						field:  "billing",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "billing_identifiers":

			if v, ok := interface{}(m.GetBillingIdentifiers()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return TenantValidationError{
						field:  "billing_identifiers",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return TenantValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// TenantValidationError is the validation error returned by
// Tenant.ValidateFields if the designated constraints aren't met.
type TenantValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TenantValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TenantValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TenantValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TenantValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TenantValidationError) ErrorName() string { return "TenantValidationError" }

// Error satisfies the builtin error interface
func (e TenantValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTenant.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TenantValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TenantValidationError{}

var _Tenant_Attributes_Pattern = regexp.MustCompile("^[a-z0-9](?:[-]?[a-z0-9]){2,}$")

// ValidateFields checks the field values on Tenants with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *Tenants) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = TenantsFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "tenants":

			for idx, item := range m.GetTenants() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return TenantsValidationError{
							field:  fmt.Sprintf("tenants[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		default:
			return TenantsValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// TenantsValidationError is the validation error returned by
// Tenants.ValidateFields if the designated constraints aren't met.
type TenantsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TenantsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TenantsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TenantsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TenantsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TenantsValidationError) ErrorName() string { return "TenantsValidationError" }

// Error satisfies the builtin error interface
func (e TenantsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTenants.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TenantsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TenantsValidationError{}

// ValidateFields checks the field values on GetTenantRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GetTenantRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = GetTenantRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "tenant_ids":

			if v, ok := interface{}(&m.TenantIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return GetTenantRequestValidationError{
						field:  "tenant_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "field_mask":

			if v, ok := interface{}(&m.FieldMask).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return GetTenantRequestValidationError{
						field:  "field_mask",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return GetTenantRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// GetTenantRequestValidationError is the validation error returned by
// GetTenantRequest.ValidateFields if the designated constraints aren't met.
type GetTenantRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTenantRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTenantRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTenantRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTenantRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTenantRequestValidationError) ErrorName() string { return "GetTenantRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetTenantRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTenantRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTenantRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTenantRequestValidationError{}

// ValidateFields checks the field values on ListTenantsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ListTenantsRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = ListTenantsRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "field_mask":

			if v, ok := interface{}(&m.FieldMask).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return ListTenantsRequestValidationError{
						field:  "field_mask",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "order":

			if _, ok := _ListTenantsRequest_Order_InLookup[m.GetOrder()]; !ok {
				return ListTenantsRequestValidationError{
					field:  "order",
					reason: "value must be in list [ tenant_id -tenant_id name -name created_at -created_at]",
				}
			}

		case "limit":

			if m.GetLimit() > 1000 {
				return ListTenantsRequestValidationError{
					field:  "limit",
					reason: "value must be less than or equal to 1000",
				}
			}

		case "page":
			// no validation rules for Page
		default:
			return ListTenantsRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// ListTenantsRequestValidationError is the validation error returned by
// ListTenantsRequest.ValidateFields if the designated constraints aren't met.
type ListTenantsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTenantsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTenantsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTenantsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTenantsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTenantsRequestValidationError) ErrorName() string {
	return "ListTenantsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTenantsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTenantsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTenantsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTenantsRequestValidationError{}

var _ListTenantsRequest_Order_InLookup = map[string]struct{}{
	"":            {},
	"tenant_id":   {},
	"-tenant_id":  {},
	"name":        {},
	"-name":       {},
	"created_at":  {},
	"-created_at": {},
}

// ValidateFields checks the field values on CreateTenantRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *CreateTenantRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = CreateTenantRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "tenant":

			if v, ok := interface{}(&m.Tenant).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return CreateTenantRequestValidationError{
						field:  "tenant",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "initial_user":

			if v, ok := interface{}(m.GetInitialUser()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return CreateTenantRequestValidationError{
						field:  "initial_user",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return CreateTenantRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// CreateTenantRequestValidationError is the validation error returned by
// CreateTenantRequest.ValidateFields if the designated constraints aren't met.
type CreateTenantRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTenantRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTenantRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTenantRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTenantRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTenantRequestValidationError) ErrorName() string {
	return "CreateTenantRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTenantRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTenantRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTenantRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTenantRequestValidationError{}

// ValidateFields checks the field values on UpdateTenantRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *UpdateTenantRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = UpdateTenantRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "tenant":

			if v, ok := interface{}(&m.Tenant).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UpdateTenantRequestValidationError{
						field:  "tenant",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "field_mask":

			if v, ok := interface{}(&m.FieldMask).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UpdateTenantRequestValidationError{
						field:  "field_mask",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return UpdateTenantRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// UpdateTenantRequestValidationError is the validation error returned by
// UpdateTenantRequest.ValidateFields if the designated constraints aren't met.
type UpdateTenantRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTenantRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTenantRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTenantRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTenantRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTenantRequestValidationError) ErrorName() string {
	return "UpdateTenantRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTenantRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTenantRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTenantRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTenantRequestValidationError{}

// ValidateFields checks the field values on
// GetTenantIdentifiersForEndDeviceEUIsRequest with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *GetTenantIdentifiersForEndDeviceEUIsRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = GetTenantIdentifiersForEndDeviceEUIsRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "join_eui":
			// no validation rules for JoinEUI
		case "dev_eui":
			// no validation rules for DevEUI
		default:
			return GetTenantIdentifiersForEndDeviceEUIsRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// GetTenantIdentifiersForEndDeviceEUIsRequestValidationError is the validation
// error returned by
// GetTenantIdentifiersForEndDeviceEUIsRequest.ValidateFields if the
// designated constraints aren't met.
type GetTenantIdentifiersForEndDeviceEUIsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTenantIdentifiersForEndDeviceEUIsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTenantIdentifiersForEndDeviceEUIsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTenantIdentifiersForEndDeviceEUIsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTenantIdentifiersForEndDeviceEUIsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTenantIdentifiersForEndDeviceEUIsRequestValidationError) ErrorName() string {
	return "GetTenantIdentifiersForEndDeviceEUIsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTenantIdentifiersForEndDeviceEUIsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTenantIdentifiersForEndDeviceEUIsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTenantIdentifiersForEndDeviceEUIsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTenantIdentifiersForEndDeviceEUIsRequestValidationError{}

// ValidateFields checks the field values on
// GetTenantIdentifiersForGatewayEUIRequest with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *GetTenantIdentifiersForGatewayEUIRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = GetTenantIdentifiersForGatewayEUIRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "eui":
			// no validation rules for EUI
		default:
			return GetTenantIdentifiersForGatewayEUIRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// GetTenantIdentifiersForGatewayEUIRequestValidationError is the validation
// error returned by GetTenantIdentifiersForGatewayEUIRequest.ValidateFields
// if the designated constraints aren't met.
type GetTenantIdentifiersForGatewayEUIRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTenantIdentifiersForGatewayEUIRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTenantIdentifiersForGatewayEUIRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTenantIdentifiersForGatewayEUIRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTenantIdentifiersForGatewayEUIRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTenantIdentifiersForGatewayEUIRequestValidationError) ErrorName() string {
	return "GetTenantIdentifiersForGatewayEUIRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTenantIdentifiersForGatewayEUIRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTenantIdentifiersForGatewayEUIRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTenantIdentifiersForGatewayEUIRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTenantIdentifiersForGatewayEUIRequestValidationError{}

// ValidateFields checks the field values on
// GetTenantIdentifiersForBillingIdentifiersRequest with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *GetTenantIdentifiersForBillingIdentifiersRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = GetTenantIdentifiersForBillingIdentifiersRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "ids":

			if v, ok := interface{}(&m.BillingIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return GetTenantIdentifiersForBillingIdentifiersRequestValidationError{
						field:  "ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return GetTenantIdentifiersForBillingIdentifiersRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// GetTenantIdentifiersForBillingIdentifiersRequestValidationError is the
// validation error returned by
// GetTenantIdentifiersForBillingIdentifiersRequest.ValidateFields if the
// designated constraints aren't met.
type GetTenantIdentifiersForBillingIdentifiersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTenantIdentifiersForBillingIdentifiersRequestValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e GetTenantIdentifiersForBillingIdentifiersRequestValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e GetTenantIdentifiersForBillingIdentifiersRequestValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e GetTenantIdentifiersForBillingIdentifiersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTenantIdentifiersForBillingIdentifiersRequestValidationError) ErrorName() string {
	return "GetTenantIdentifiersForBillingIdentifiersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTenantIdentifiersForBillingIdentifiersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTenantIdentifiersForBillingIdentifiersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTenantIdentifiersForBillingIdentifiersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTenantIdentifiersForBillingIdentifiersRequestValidationError{}

// ValidateFields checks the field values on GetTenantRegistryTotalsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned.
func (m *GetTenantRegistryTotalsRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = GetTenantRegistryTotalsRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "tenant_ids":

			if v, ok := interface{}(m.TenantIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return GetTenantRegistryTotalsRequestValidationError{
						field:  "tenant_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "field_mask":

			if v, ok := interface{}(&m.FieldMask).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return GetTenantRegistryTotalsRequestValidationError{
						field:  "field_mask",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return GetTenantRegistryTotalsRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// GetTenantRegistryTotalsRequestValidationError is the validation error
// returned by GetTenantRegistryTotalsRequest.ValidateFields if the designated
// constraints aren't met.
type GetTenantRegistryTotalsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTenantRegistryTotalsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTenantRegistryTotalsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTenantRegistryTotalsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTenantRegistryTotalsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTenantRegistryTotalsRequestValidationError) ErrorName() string {
	return "GetTenantRegistryTotalsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTenantRegistryTotalsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTenantRegistryTotalsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTenantRegistryTotalsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTenantRegistryTotalsRequestValidationError{}

// ValidateFields checks the field values on TenantRegistryTotals with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *TenantRegistryTotals) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = TenantRegistryTotalsFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "applications":
			// no validation rules for Applications
		case "clients":
			// no validation rules for Clients
		case "end_devices":
			// no validation rules for EndDevices
		case "gateways":
			// no validation rules for Gateways
		case "organizations":
			// no validation rules for Organizations
		case "users":
			// no validation rules for Users
		default:
			return TenantRegistryTotalsValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// TenantRegistryTotalsValidationError is the validation error returned by
// TenantRegistryTotals.ValidateFields if the designated constraints aren't met.
type TenantRegistryTotalsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TenantRegistryTotalsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TenantRegistryTotalsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TenantRegistryTotalsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TenantRegistryTotalsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TenantRegistryTotalsValidationError) ErrorName() string {
	return "TenantRegistryTotalsValidationError"
}

// Error satisfies the builtin error interface
func (e TenantRegistryTotalsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTenantRegistryTotals.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TenantRegistryTotalsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TenantRegistryTotalsValidationError{}
